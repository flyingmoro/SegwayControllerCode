{\rtf1\ansi\deff0{\fonttbl{\f0\fnil\fcharset0 Courier New;}}
{\colortbl ;\red128\green158\blue194;\red0\green77\blue187;\red0\green176\blue80;\red255\green192\blue0;}
{\*\generator Msftedit 5.41.21.2510;}\viewkind4\uc1\pard\cf1\lang1031\f0\fs22 // I2Cdev library collection - MPU6050 I2C device class, 6-axis MotionApps 2.0 implementation\par
// Based on InvenSense MPU-6050 register map document rev. 2.0, 5/19/2011 (RM-MPU-6000A-00)\par
// 5/20/2013 by Jeff Rowberg <jeff@rowberg.net>\par
// Updates should (hopefully) always be available at https://github.com/jrowberg/i2cdevlib\par
//\par
// Changelog:\par
//     ... - ongoing debug release\par
\par
/* ============================================\par
I2Cdev device library code is placed under the MIT license\par
Copyright (c) 2012 Jeff Rowberg\par
\par
Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\par
copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\par
\par
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\par
\par
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\par
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\par
===============================================\par
*/\cf0\par
\par
\cf2 #ifndef _MPU6050_6AXIS_MOTIONAPPS20_H_\par
#define _MPU6050_6AXIS_MOTIONAPPS20_H_\par
\par
#include "I2Cdev.h"\par
#include "helper_3dmath.h"\cf0\par
\par
\cf3 // MotionApps 2.0 DMP implementation, built using the MPU-6050EVB evaluation board\cf0\par
\cf2 #define MPU6050_INCLUDE_DMP_MOTIONAPPS20\par
\par
#include "MPU6050.h"\par
\cf0\par
\cf3 // Tom Carpenter's conditional PROGMEM code\par
// http://forum.arduino.cc/index.php?topic=129407.0\cf0\par
#ifdef __AVR__\par
    #include <avr/pgmspace.h>\par
#else\par
    \cf3 // Teensy 3.0 library conditional PROGMEM code from Paul Stoffregen\cf0\par
    #ifndef __PGMSPACE_H_\par
        #define __PGMSPACE_H_ 1\par
        #include <inttypes.h>\par
\par
        #define PROGMEM\par
        #define PGM_P  const char *\par
        #define PSTR(str) (str)\par
        #define F(x) x\par
\par
        typedef void prog_void;\par
        typedef char prog_char;\par
        typedef unsigned char prog_uchar;\par
        typedef int8_t prog_int8_t;\par
        typedef uint8_t prog_uint8_t;\par
        typedef int16_t prog_int16_t;\par
        typedef uint16_t prog_uint16_t;\par
        typedef int32_t prog_int32_t;\par
        typedef uint32_t prog_uint32_t;\par
        \par
        #define strcpy_P(dest, src) strcpy((dest), (src))\par
        #define strcat_P(dest, src) strcat((dest), (src))\par
        #define strcmp_P(a, b) strcmp((a), (b))\par
        \par
        #define pgm_read_byte(addr) (*(const unsigned char *)(addr))\par
        #define pgm_read_word(addr) (*(const unsigned short *)(addr))\par
        #define pgm_read_dword(addr) (*(const unsigned long *)(addr))\par
        #define pgm_read_float(addr) (*(const float *)(addr))\par
        \par
        #define pgm_read_byte_near(addr) pgm_read_byte(addr)\par
        #define pgm_read_word_near(addr) pgm_read_word(addr)\par
        #define pgm_read_dword_near(addr) pgm_read_dword(addr)\par
        #define pgm_read_float_near(addr) pgm_read_float(addr)\par
        #define pgm_read_byte_far(addr) pgm_read_byte(addr)\par
        #define pgm_read_word_far(addr) pgm_read_word(addr)\par
        #define pgm_read_dword_far(addr) pgm_read_dword(addr)\par
        #define pgm_read_float_far(addr) pgm_read_float(addr)\par
    #endif\par
#endif\par
\par
\cf3 /* Source is from the InvenSense MotionApps v2 demo code. Original source is unavailable, unless you happen to be amazing as decompiling binary by hand (in which case, please contact me, and I'm totally serious). Also, I'd like to offer many, many thanks to Noah Zerkin for all of the DMP reverse-engineering he did to help make this bit of wizardry possible.*/\par
\par
// NOTE! Enabling DEBUG adds about 3.3kB to the flash program size.\par
// Debug output is now working even on ATMega328P MCUs (e.g. Arduino Uno)\par
// after moving string constants to flash memory storage using the F()\par
// compiler macro (Arduino IDE 1.0+ required).\par
\par
//#define DEBUG\par
\cf0 #ifdef DEBUG\par
    #define DEBUG_PRINT(x) Serial.print(x)\par
    #define DEBUG_PRINTF(x, y) Serial.print(x, y)\par
    #define DEBUG_PRINTLN(x) Serial.println(x)\par
    #define DEBUG_PRINTLNF(x, y) Serial.println(x, y)\par
#else\par
    #define DEBUG_PRINT(x)\par
    #define DEBUG_PRINTF(x, y)\par
    #define DEBUG_PRINTLN(x)\par
    #define DEBUG_PRINTLNF(x, y)\par
#endif\par
\par
#define MPU6050_DMP_CODE_SIZE       1929    \cf3 // dmpMemory[]\cf0\par
#define MPU6050_DMP_CONFIG_SIZE     192     \cf3 // dmpConfig[]\cf0\par
#define MPU6050_DMP_UPDATES_SIZE    47      \cf3 // dmpUpdates[]\cf0\par
\par
\cf2 /* ================================================================================================ *\cf0\par
 | Default MotionApps v2.0 42-byte FIFO packet structure:                                           |\par
 |                                                                                                  |\par
 | \cf4 [QUAT W][      ][QUAT X][      ][QUAT Y][      ][QUAT Z][      ][GYRO X][      ][GYRO Y][      ] \par
\cf0 |\par
 |   0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19  20  21  22  23  \par
|\par
 |                                                                                                  |\par
 | \cf4 [GYRO Z][      ][ACC X ][      ][ACC Y ][      ][ACC Z ][      ][      ] \cf0                         \par
|\par
 |  24  25  26  27  28  29  30  31  32  33  34  35  36  37  38  39  40  41                          \par
|\par
 * \cf2 ================================================================================================ */\par
\cf0\par
\cf3 // this block of memory gets written to the MPU on start-up, and it seems to be volatile memory, so it has to be done each time (it only takes ~1 second though)\par
\par
\cf0 const unsigned char dmpMemory[MPU6050_DMP_CODE_SIZE] PROGMEM = \{\par
    \cf3 // bank 0, 256 bytes\cf0\par
    0xFB, 0x00, 0x00, 0x3E, 0x00, 0x0B, 0x00, 0x36, 0x00, 0x01, 0x00, 0x02, 0x00, 0x03, 0x00, 0x00,\par
    0x00, 0x65, 0x00, 0x54, 0xFF, 0xEF, 0x00, 0x00, 0xFA, 0x80, 0x00, 0x0B, 0x12, 0x82, 0x00, 0x01,\par
    0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\par
    0x00, 0x28, 0x00, 0x00, 0xFF, 0xFF, 0x45, 0x81, 0xFF, 0xFF, 0xFA, 0x72, 0x00, 0x00, 0x00, 0x00,\par
    0x00, 0x00, 0x03, 0xE8, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x7F, 0xFF, 0xFF, 0xFE, 0x80, 0x01,\par
    0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\par
    0x00, 0x3E, 0x03, 0x30, 0x40, 0x00, 0x00, 0x00, 0x02, 0xCA, 0xE3, 0x09, 0x3E, 0x80, 0x00, 0x00,\par
    0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,\par
    0x41, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x0B, 0x2A, 0x00, 0x00, 0x16, 0x55, 0x00, 0x00, 0x21, 0x82,\par
    0xFD, 0x87, 0x26, 0x50, 0xFD, 0x80, 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x05, 0x80, 0x00,\par
    0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,\par
    0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x6F, 0x00, 0x02, 0x65, 0x32, 0x00, 0x00, 0x5E, 0xC0,\par
    0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\par
    0xFB, 0x8C, 0x6F, 0x5D, 0xFD, 0x5D, 0x08, 0xD9, 0x00, 0x7C, 0x73, 0x3B, 0x00, 0x6C, 0x12, 0xCC,\par
    0x32, 0x00, 0x13, 0x9D, 0x32, 0x00, 0xD0, 0xD6, 0x32, 0x00, 0x08, 0x00, 0x40, 0x00, 0x01, 0xF4,\par
    0xFF, 0xE6, 0x80, 0x79, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD0, 0xD6, 0x00, 0x00, 0x27, 0x10,\par
\par
    \cf3 // bank 1, 256 bytes\cf0\par
    0xFB, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\par
    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00,\par
    0x00, 0x00, 0xFA, 0x36, 0xFF, 0xBC, 0x30, 0x8E, 0x00, 0x05, 0xFB, 0xF0, 0xFF, 0xD9, 0x5B, 0xC8,\par
    0xFF, 0xD0, 0x9A, 0xBE, 0x00, 0x00, 0x10, 0xA9, 0xFF, 0xF4, 0x1E, 0xB2, 0x00, 0xCE, 0xBB, 0xF7,\par
    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x02, 0x00, 0x02, 0x02, 0x00, 0x00, 0x0C,\par
    0xFF, 0xC2, 0x80, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0xCF, 0x80, 0x00, 0x40, 0x00, 0x00, 0x00,\par
    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x14,\par
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\par
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\par
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\par
    0x00, 0x00, 0x00, 0x00, 0x03, 0x3F, 0x68, 0xB6, 0x79, 0x35, 0x28, 0xBC, 0xC6, 0x7E, 0xD1, 0x6C,\par
    0x80, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB2, 0x6A, 0x00, 0x00, 0x00, 0x00,\par
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xF0, 0x00, 0x00, 0x00, 0x30,\par
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\par
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\par
    0x00, 0x00, 0x25, 0x4D, 0x00, 0x2F, 0x70, 0x6D, 0x00, 0x00, 0x05, 0xAE, 0x00, 0x0C, 0x02, 0xD0,\par
\par
    \cf3 // bank 2, 256 bytes\cf0\par
    0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x00, 0x54, 0xFF, 0xEF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\par
    0x00, 0x00, 0x01, 0x00, 0x00, 0x44, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x01, 0x00,\par
    0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0xFF, 0xEF, 0x00, 0x00,\par
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\par
    0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\par
    0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\par
    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\par
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\par
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\par
    0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\par
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\par
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,\par
    0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\par
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\par
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\par
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\par
\par
    \cf3 // bank 3, 256 bytes\cf0\par
    0xD8, 0xDC, 0xBA, 0xA2, 0xF1, 0xDE, 0xB2, 0xB8, 0xB4, 0xA8, 0x81, 0x91, 0xF7, 0x4A, 0x90, 0x7F,\par
    0x91, 0x6A, 0xF3, 0xF9, 0xDB, 0xA8, 0xF9, 0xB0, 0xBA, 0xA0, 0x80, 0xF2, 0xCE, 0x81, 0xF3, 0xC2,\par
    0xF1, 0xC1, 0xF2, 0xC3, 0xF3, 0xCC, 0xA2, 0xB2, 0x80, 0xF1, 0xC6, 0xD8, 0x80, 0xBA, 0xA7, 0xDF,\par
    0xDF, 0xDF, 0xF2, 0xA7, 0xC3, 0xCB, 0xC5, 0xB6, 0xF0, 0x87, 0xA2, 0x94, 0x24, 0x48, 0x70, 0x3C,\par
    0x95, 0x40, 0x68, 0x34, 0x58, 0x9B, 0x78, 0xA2, 0xF1, 0x83, 0x92, 0x2D, 0x55, 0x7D, 0xD8, 0xB1,\par
    0xB4, 0xB8, 0xA1, 0xD0, 0x91, 0x80, 0xF2, 0x70, 0xF3, 0x70, 0xF2, 0x7C, 0x80, 0xA8, 0xF1, 0x01,\par
    0xB0, 0x98, 0x87, 0xD9, 0x43, 0xD8, 0x86, 0xC9, 0x88, 0xBA, 0xA1, 0xF2, 0x0E, 0xB8, 0x97, 0x80,\par
    0xF1, 0xA9, 0xDF, 0xDF, 0xDF, 0xAA, 0xDF, 0xDF, 0xDF, 0xF2, 0xAA, 0xC5, 0xCD, 0xC7, 0xA9, 0x0C,\par
    0xC9, 0x2C, 0x97, 0x97, 0x97, 0x97, 0xF1, 0xA9, 0x89, 0x26, 0x46, 0x66, 0xB0, 0xB4, 0xBA, 0x80,\par
    0xAC, 0xDE, 0xF2, 0xCA, 0xF1, 0xB2, 0x8C, 0x02, 0xA9, 0xB6, 0x98, 0x00, 0x89, 0x0E, 0x16, 0x1E,\par
    0xB8, 0xA9, 0xB4, 0x99, 0x2C, 0x54, 0x7C, 0xB0, 0x8A, 0xA8, 0x96, 0x36, 0x56, 0x76, 0xF1, 0xB9,\par
    0xAF, 0xB4, 0xB0, 0x83, 0xC0, 0xB8, 0xA8, 0x97, 0x11, 0xB1, 0x8F, 0x98, 0xB9, 0xAF, 0xF0, 0x24,\par
    0x08, 0x44, 0x10, 0x64, 0x18, 0xF1, 0xA3, 0x29, 0x55, 0x7D, 0xAF, 0x83, 0xB5, 0x93, 0xAF, 0xF0,\par
    0x00, 0x28, 0x50, 0xF1, 0xA3, 0x86, 0x9F, 0x61, 0xA6, 0xDA, 0xDE, 0xDF, 0xD9, 0xFA, 0xA3, 0x86,\par
    0x96, 0xDB, 0x31, 0xA6, 0xD9, 0xF8, 0xDF, 0xBA, 0xA6, 0x8F, 0xC2, 0xC5, 0xC7, 0xB2, 0x8C, 0xC1,\par
    0xB8, 0xA2, 0xDF, 0xDF, 0xDF, 0xA3, 0xDF, 0xDF, 0xDF, 0xD8, 0xD8, 0xF1, 0xB8, 0xA8, 0xB2, 0x86,\par
\par
    \cf3 // bank 4, 256 bytes\cf0\par
    0xB4, 0x98, 0x0D, 0x35, 0x5D, 0xB8, 0xAA, 0x98, 0xB0, 0x87, 0x2D, 0x35, 0x3D, 0xB2, 0xB6, 0xBA,\par
    0xAF, 0x8C, 0x96, 0x19, 0x8F, 0x9F, 0xA7, 0x0E, 0x16, 0x1E, 0xB4, 0x9A, 0xB8, 0xAA, 0x87, 0x2C,\par
    0x54, 0x7C, 0xB9, 0xA3, 0xDE, 0xDF, 0xDF, 0xA3, 0xB1, 0x80, 0xF2, 0xC4, 0xCD, 0xC9, 0xF1, 0xB8,\par
    0xA9, 0xB4, 0x99, 0x83, 0x0D, 0x35, 0x5D, 0x89, 0xB9, 0xA3, 0x2D, 0x55, 0x7D, 0xB5, 0x93, 0xA3,\par
    0x0E, 0x16, 0x1E, 0xA9, 0x2C, 0x54, 0x7C, 0xB8, 0xB4, 0xB0, 0xF1, 0x97, 0x83, 0xA8, 0x11, 0x84,\par
    0xA5, 0x09, 0x98, 0xA3, 0x83, 0xF0, 0xDA, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0xD8, 0xF1, 0xA5,\par
    0x29, 0x55, 0x7D, 0xA5, 0x85, 0x95, 0x02, 0x1A, 0x2E, 0x3A, 0x56, 0x5A, 0x40, 0x48, 0xF9, 0xF3,\par
    0xA3, 0xD9, 0xF8, 0xF0, 0x98, 0x83, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0x97, 0x82, 0xA8, 0xF1,\par
    0x11, 0xF0, 0x98, 0xA2, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0xDA, 0xF3, 0xDE, 0xD8, 0x83, 0xA5,\par
    0x94, 0x01, 0xD9, 0xA3, 0x02, 0xF1, 0xA2, 0xC3, 0xC5, 0xC7, 0xD8, 0xF1, 0x84, 0x92, 0xA2, 0x4D,\par
    0xDA, 0x2A, 0xD8, 0x48, 0x69, 0xD9, 0x2A, 0xD8, 0x68, 0x55, 0xDA, 0x32, 0xD8, 0x50, 0x71, 0xD9,\par
    0x32, 0xD8, 0x70, 0x5D, 0xDA, 0x3A, 0xD8, 0x58, 0x79, 0xD9, 0x3A, 0xD8, 0x78, 0x93, 0xA3, 0x4D,\par
    0xDA, 0x2A, 0xD8, 0x48, 0x69, 0xD9, 0x2A, 0xD8, 0x68, 0x55, 0xDA, 0x32, 0xD8, 0x50, 0x71, 0xD9,\par
    0x32, 0xD8, 0x70, 0x5D, 0xDA, 0x3A, 0xD8, 0x58, 0x79, 0xD9, 0x3A, 0xD8, 0x78, 0xA8, 0x8A, 0x9A,\par
    0xF0, 0x28, 0x50, 0x78, 0x9E, 0xF3, 0x88, 0x18, 0xF1, 0x9F, 0x1D, 0x98, 0xA8, 0xD9, 0x08, 0xD8,\par
    0xC8, 0x9F, 0x12, 0x9E, 0xF3, 0x15, 0xA8, 0xDA, 0x12, 0x10, 0xD8, 0xF1, 0xAF, 0xC8, 0x97, 0x87,\par
\par
    \cf3 // bank 5, 256 bytes\cf0\par
    0x34, 0xB5, 0xB9, 0x94, 0xA4, 0x21, 0xF3, 0xD9, 0x22, 0xD8, 0xF2, 0x2D, 0xF3, 0xD9, 0x2A, 0xD8,\par
    0xF2, 0x35, 0xF3, 0xD9, 0x32, 0xD8, 0x81, 0xA4, 0x60, 0x60, 0x61, 0xD9, 0x61, 0xD8, 0x6C, 0x68,\par
    0x69, 0xD9, 0x69, 0xD8, 0x74, 0x70, 0x71, 0xD9, 0x71, 0xD8, 0xB1, 0xA3, 0x84, 0x19, 0x3D, 0x5D,\par
    0xA3, 0x83, 0x1A, 0x3E, 0x5E, 0x93, 0x10, 0x30, 0x81, 0x10, 0x11, 0xB8, 0xB0, 0xAF, 0x8F, 0x94,\par
    0xF2, 0xDA, 0x3E, 0xD8, 0xB4, 0x9A, 0xA8, 0x87, 0x29, 0xDA, 0xF8, 0xD8, 0x87, 0x9A, 0x35, 0xDA,\par
    0xF8, 0xD8, 0x87, 0x9A, 0x3D, 0xDA, 0xF8, 0xD8, 0xB1, 0xB9, 0xA4, 0x98, 0x85, 0x02, 0x2E, 0x56,\par
    0xA5, 0x81, 0x00, 0x0C, 0x14, 0xA3, 0x97, 0xB0, 0x8A, 0xF1, 0x2D, 0xD9, 0x28, 0xD8, 0x4D, 0xD9,\par
    0x48, 0xD8, 0x6D, 0xD9, 0x68, 0xD8, 0xB1, 0x84, 0x0D, 0xDA, 0x0E, 0xD8, 0xA3, 0x29, 0x83, 0xDA,\par
    0x2C, 0x0E, 0xD8, 0xA3, 0x84, 0x49, 0x83, 0xDA, 0x2C, 0x4C, 0x0E, 0xD8, 0xB8, 0xB0, 0xA8, 0x8A,\par
    0x9A, 0xF5, 0x20, 0xAA, 0xDA, 0xDF, 0xD8, 0xA8, 0x40, 0xAA, 0xD0, 0xDA, 0xDE, 0xD8, 0xA8, 0x60,\par
    0xAA, 0xDA, 0xD0, 0xDF, 0xD8, 0xF1, 0x97, 0x86, 0xA8, 0x31, 0x9B, 0x06, 0x99, 0x07, 0xAB, 0x97,\par
    0x28, 0x88, 0x9B, 0xF0, 0x0C, 0x20, 0x14, 0x40, 0xB8, 0xB0, 0xB4, 0xA8, 0x8C, 0x9C, 0xF0, 0x04,\par
    0x28, 0x51, 0x79, 0x1D, 0x30, 0x14, 0x38, 0xB2, 0x82, 0xAB, 0xD0, 0x98, 0x2C, 0x50, 0x50, 0x78,\par
    0x78, 0x9B, 0xF1, 0x1A, 0xB0, 0xF0, 0x8A, 0x9C, 0xA8, 0x29, 0x51, 0x79, 0x8B, 0x29, 0x51, 0x79,\par
    0x8A, 0x24, 0x70, 0x59, 0x8B, 0x20, 0x58, 0x71, 0x8A, 0x44, 0x69, 0x38, 0x8B, 0x39, 0x40, 0x68,\par
    0x8A, 0x64, 0x48, 0x31, 0x8B, 0x30, 0x49, 0x60, 0xA5, 0x88, 0x20, 0x09, 0x71, 0x58, 0x44, 0x68,\par
\par
    \cf3 // bank 6, 256 bytes\cf0\par
    0x11, 0x39, 0x64, 0x49, 0x30, 0x19, 0xF1, 0xAC, 0x00, 0x2C, 0x54, 0x7C, 0xF0, 0x8C, 0xA8, 0x04,\par
    0x28, 0x50, 0x78, 0xF1, 0x88, 0x97, 0x26, 0xA8, 0x59, 0x98, 0xAC, 0x8C, 0x02, 0x26, 0x46, 0x66,\par
    0xF0, 0x89, 0x9C, 0xA8, 0x29, 0x51, 0x79, 0x24, 0x70, 0x59, 0x44, 0x69, 0x38, 0x64, 0x48, 0x31,\par
    0xA9, 0x88, 0x09, 0x20, 0x59, 0x70, 0xAB, 0x11, 0x38, 0x40, 0x69, 0xA8, 0x19, 0x31, 0x48, 0x60,\par
    0x8C, 0xA8, 0x3C, 0x41, 0x5C, 0x20, 0x7C, 0x00, 0xF1, 0x87, 0x98, 0x19, 0x86, 0xA8, 0x6E, 0x76,\par
    0x7E, 0xA9, 0x99, 0x88, 0x2D, 0x55, 0x7D, 0x9E, 0xB9, 0xA3, 0x8A, 0x22, 0x8A, 0x6E, 0x8A, 0x56,\par
    0x8A, 0x5E, 0x9F, 0xB1, 0x83, 0x06, 0x26, 0x46, 0x66, 0x0E, 0x2E, 0x4E, 0x6E, 0x9D, 0xB8, 0xAD,\par
    0x00, 0x2C, 0x54, 0x7C, 0xF2, 0xB1, 0x8C, 0xB4, 0x99, 0xB9, 0xA3, 0x2D, 0x55, 0x7D, 0x81, 0x91,\par
    0xAC, 0x38, 0xAD, 0x3A, 0xB5, 0x83, 0x91, 0xAC, 0x2D, 0xD9, 0x28, 0xD8, 0x4D, 0xD9, 0x48, 0xD8,\par
    0x6D, 0xD9, 0x68, 0xD8, 0x8C, 0x9D, 0xAE, 0x29, 0xD9, 0x04, 0xAE, 0xD8, 0x51, 0xD9, 0x04, 0xAE,\par
    0xD8, 0x79, 0xD9, 0x04, 0xD8, 0x81, 0xF3, 0x9D, 0xAD, 0x00, 0x8D, 0xAE, 0x19, 0x81, 0xAD, 0xD9,\par
    0x01, 0xD8, 0xF2, 0xAE, 0xDA, 0x26, 0xD8, 0x8E, 0x91, 0x29, 0x83, 0xA7, 0xD9, 0xAD, 0xAD, 0xAD,\par
    0xAD, 0xF3, 0x2A, 0xD8, 0xD8, 0xF1, 0xB0, 0xAC, 0x89, 0x91, 0x3E, 0x5E, 0x76, 0xF3, 0xAC, 0x2E,\par
    0x2E, 0xF1, 0xB1, 0x8C, 0x5A, 0x9C, 0xAC, 0x2C, 0x28, 0x28, 0x28, 0x9C, 0xAC, 0x30, 0x18, 0xA8,\par
    0x98, 0x81, 0x28, 0x34, 0x3C, 0x97, 0x24, 0xA7, 0x28, 0x34, 0x3C, 0x9C, 0x24, 0xF2, 0xB0, 0x89,\par
    0xAC, 0x91, 0x2C, 0x4C, 0x6C, 0x8A, 0x9B, 0x2D, 0xD9, 0xD8, 0xD8, 0x51, 0xD9, 0xD8, 0xD8, 0x79,\par
\par
    \cf3 // bank 7, 138 bytes (remainder)\cf0\par
    0xD9, 0xD8, 0xD8, 0xF1, 0x9E, 0x88, 0xA3, 0x31, 0xDA, 0xD8, 0xD8, 0x91, 0x2D, 0xD9, 0x28, 0xD8,\par
    0x4D, 0xD9, 0x48, 0xD8, 0x6D, 0xD9, 0x68, 0xD8, 0xB1, 0x83, 0x93, 0x35, 0x3D, 0x80, 0x25, 0xDA,\par
    0xD8, 0xD8, 0x85, 0x69, 0xDA, 0xD8, 0xD8, 0xB4, 0x93, 0x81, 0xA3, 0x28, 0x34, 0x3C, 0xF3, 0xAB,\par
    0x8B, 0xF8, 0xA3, 0x91, 0xB6, 0x09, 0xB4, 0xD9, 0xAB, 0xDE, 0xFA, 0xB0, 0x87, 0x9C, 0xB9, 0xA3,\par
    0xDD, 0xF1, 0xA3, 0xA3, 0xA3, 0xA3, 0x95, 0xF1, 0xA3, 0xA3, 0xA3, 0x9D, 0xF1, 0xA3, 0xA3, 0xA3,\par
    0xA3, 0xF2, 0xA3, 0xB4, 0x90, 0x80, 0xF2, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3,\par
    0xA3, 0xB2, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xB0, 0x87, 0xB5, 0x99, 0xF1, 0xA3, 0xA3, 0xA3,\par
    0x98, 0xF1, 0xA3, 0xA3, 0xA3, 0xA3, 0x97, 0xA3, 0xA3, 0xA3, 0xA3, 0xF3, 0x9B, 0xA3, 0xA3, 0xDC,\par
    0xB9, 0xA7, 0xF1, 0x26, 0x26, 0x26, 0xD8, 0xD8, 0xFF\par
\};\par
\par
\cf3 // thanks to Noah Zerkin for piecing this stuff together!\par
\cf0\par
const unsigned char dmpConfig[MPU6050_DMP_CONFIG_SIZE] PROGMEM = \{\par
\cf3 //  BANK    OFFSET  LENGTH  [DATA]\cf0\par
    0x03,   0x7B,   0x03,   0x4C, 0xCD, 0x6C,         \cf3 // FCFG_1 \cf0 inv_set_gyro_calibration\par
    0x03,   0xAB,   0x03,   0x36, 0x56, 0x76,         \cf3 // FCFG_3\cf0  inv_set_gyro_calibration\par
    0x00,   0x68,   0x04,   0x02, 0xCB, 0x47, 0xA2,   \cf3 // D_0_104\cf0  inv_set_gyro_calibration\par
    0x02,   0x18,   0x04,   0x00, 0x05, 0x8B, 0xC1,   \cf3 // D_0_24\cf0  inv_set_gyro_calibration\par
    0x01,   0x0C,   0x04,   0x00, 0x00, 0x00, 0x00,   \cf3 // D_1_152\cf0  inv_set_accel_calibration\par
    0x03,   0x7F,   0x06,   0x0C, 0xC9, 0x2C, 0x97, 0x97, 0x97,\par
\cf3 // FCFG_2 \par
\cf0 inv_set_accel_calibration\par
    0x03,   0x89,   0x03,   0x26, 0x46, 0x66,         \cf3 // FCFG_7 \cf0 inv_set_accel_calibration\par
    0x00,   0x6C,   0x02,   0x20, 0x00,               \cf3 // D_0_108\cf0  inv_set_accel_calibration\par
    0x02,   0x40,   0x04,   0x00, 0x00, 0x00, 0x00,   \cf3 // CPASS_MTX_00 \par
\cf0 inv_set_compass_calibration\par
    0x02,   0x44,   0x04,   0x00, 0x00, 0x00, 0x00,   \par
\cf3 // CPASS_MTX_01\cf0\par
    0x02,   0x48,   0x04,   0x00, 0x00, 0x00, 0x00,   \par
\cf3 // CPASS_MTX_02\cf0\par
    0x02,   0x4C,   0x04,   0x00, 0x00, 0x00, 0x00,   \par
\cf3 // CPASS_MTX_10\cf0\par
    0x02,   0x50,   0x04,   0x00, 0x00, 0x00, 0x00,   \par
\cf3 // CPASS_MTX_11\cf0\par
    0x02,   0x54,   0x04,   0x00, 0x00, 0x00, 0x00,   \par
\cf3 // CPASS_MTX_12\cf0\par
    0x02,   0x58,   0x04,   0x00, 0x00, 0x00, 0x00,   \par
\cf3 // CPASS_MTX_20\cf0\par
    0x02,   0x5C,   0x04,   0x00, 0x00, 0x00, 0x00,   \par
\cf3 // CPASS_MTX_21\cf0\par
    0x02,   0xBC,   0x04,   0x00, 0x00, 0x00, 0x00,   \par
\cf3 // CPASS_MTX_22\cf0\par
    0x01,   0xEC,   0x04,   0x00, 0x00, 0x40, 0x00,   \par
\cf3 // D_1_236 \par
\cf0 inv_apply_endian_accel\par
    0x03,   0x7F,   0x06,   0x0C, 0xC9, 0x2C, 0x97, 0x97, 0x97, \par
\cf3 // FCFG_2 \cf0\par
inv_set_mpu_sensors\par
    0x04,   0x02,   0x03,   0x0D, 0x35, 0x5D,         \par
\cf3 // CFG_MOTION_BIAS\par
\cf0 inv_turn_on_bias_from_no_motion\par
    0x04,   0x09,   0x04,   0x87, 0x2D, 0x35, 0x3D,   \cf3 // FCFG_5 \cf0 inv_set_bias_update\par
    0x00,   0xA3,   0x01,   0x00,                     \cf3 // D_0_163\cf0  inv_set_dead_zone\par
                 \cf3 // SPECIAL 0x01 = enable interrupts\cf0\par
    0x00,   0x00,   0x00,   0x01, \cf3 // SET INT_ENABLE at i=22\cf0 , SPECIAL INSTRUCTION\par
    0x07,   0x86,   0x01,   0xFE,                     \cf3 // CFG_6 \cf0 inv_set_fifo_interupt\par
    0x07,   0x41,   0x05,   0xF1, 0x20, 0x28, 0x30, 0x38, \cf3 // CFG_8\cf0  inv_send_quaternion\par
    0x07,   0x7E,   0x01,   0x30,                     \cf3 // CFG_16 \cf0 inv_set_footer\par
    0x07,   0x46,   0x01,   0x9A,              \cf3 // CFG_GYRO_SOURCE \cf0 inv_send_gyro\par
    0x07,   0x47,   0x04,   0xF1, 0x28, 0x30, 0x38,   \cf3 // CFG_9 \cf0 inv_send_gyro -> inv_construct3_fifo\par
    0x07,   0x6C,   0x04,   0xF1, 0x28, 0x30, 0x38,   \cf3 // CFG_12\cf0  inv_send_accel -> inv_construct3_fifo\par
    0x02,   0x16,   0x02,   0x00, 0x01                \cf3 // D_0_22\cf0  inv_set_fifo_rate\par
\par
    \cf3 // This very last 0x01 WAS a 0x09, which drops the FIFO rate down to 20 Hz. 0x07 is 25 Hz, 0x01 is 100Hz. Going faster than 100Hz (0x00=200Hz) tends to result in very noisy data. DMP output frequency is calculated easily using this equation: (200Hz / (1 + value))\par
    // It is important to make sure the host processor can keep up with reading and processing the FIFO output at the desired rate. Handling FIFO overflow cleanly is also a good idea.\par
\cf0\};\cf3\par
\cf0\par
const unsigned char dmpUpdates[MPU6050_DMP_UPDATES_SIZE] PROGMEM = \{\par
    0x01,   0xB2,   0x02,   0xFF, 0xFF,\par
    0x01,   0x90,   0x04,   0x09, 0x23, 0xA1, 0x35,\par
    0x01,   0x6A,   0x02,   0x06, 0x00,\par
    0x01,   0x60,   0x08,   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\par
    0x00,   0x60,   0x04,   0x40, 0x00, 0x00, 0x00,\par
    0x01,   0x62,   0x02,   0x00, 0x00,\par
    0x00,   0x60,   0x04,   0x00, 0x40, 0x00, 0x00\par
\};\par
\par
uint8_t MPU6050::dmpInitialize() \{\par
    \cf3 // reset device\cf0\par
    DEBUG_PRINTLN(F("\\n\\nResetting MPU6050..."));\par
    reset();\par
    delay(30); \cf3 // wait after reset\cf0\par
\par
    \cf3 // enable sleep mode and wake cycle\cf0\par
    /*Serial.println(F("Enabling sleep mode..."));\par
    setSleepEnabled(true);\par
    Serial.println(F("Enabling wake cycle..."));\par
    setWakeCycleEnabled(true);*/\par
\par
    \cf3 // disable sleep mode\cf0\par
    DEBUG_PRINTLN(F("Disabling sleep mode..."));\par
    setSleepEnabled(false);\par
\par
    \cf3 // get MPU hardware revision\cf0\par
    DEBUG_PRINTLN(F("Selecting user bank 16..."));\par
    setMemoryBank(0x10, true, true);\par
    DEBUG_PRINTLN(F("Selecting memory byte 6..."));\par
    setMemoryStartAddress(0x06);\par
    DEBUG_PRINTLN(F("Checking hardware revision..."));\par
    DEBUG_PRINT(F("Revision @ user[16][6] = "));\par
    DEBUG_PRINTLNF(readMemoryByte(), HEX);\par
    DEBUG_PRINTLN(F("Resetting memory bank selection to 0..."));\par
    setMemoryBank(0, false, false);\par
\par
    \cf3 // check OTP bank valid\cf0\par
    DEBUG_PRINTLN(F("Reading OTP bank valid flag..."));\par
    DEBUG_PRINT(F("OTP bank is "));\par
    DEBUG_PRINTLN(getOTPBankValid() ? F("valid!") : F("invalid!"));\par
\par
    \cf3 // get X/Y/Z gyro offsets\cf0\par
    DEBUG_PRINTLN(F("Reading gyro offset TC values..."));\par
    int8_t xgOffsetTC = getXGyroOffsetTC();\par
    int8_t ygOffsetTC = getYGyroOffsetTC();\par
    int8_t zgOffsetTC = getZGyroOffsetTC();\par
    DEBUG_PRINT(F("X gyro offset = "));\par
    DEBUG_PRINTLN(xgOffsetTC);\par
    DEBUG_PRINT(F("Y gyro offset = "));\par
    DEBUG_PRINTLN(ygOffsetTC);\par
    DEBUG_PRINT(F("Z gyro offset = "));\par
    DEBUG_PRINTLN(zgOffsetTC);\par
\par
    \cf3 // setup weird slave stuff (?)\cf0\par
    DEBUG_PRINTLN(F("Setting slave 0 address to 0x7F..."));\par
    setSlaveAddress(0, 0x7F);\par
    DEBUG_PRINTLN(F("Disabling I2C Master mode..."));\par
    setI2CMasterModeEnabled(false);\par
    DEBUG_PRINTLN(F("Setting slave 0 address to 0x68 (self)..."));\par
    setSlaveAddress(0, 0x68);\par
    DEBUG_PRINTLN(F("Resetting I2C Master control..."));\par
    resetI2CMaster();\par
    delay(20);\par
\par
    \cf3 // load DMP code into memory banks\cf0\par
    DEBUG_PRINT(F("Writing DMP code to MPU memory banks ("));\par
    DEBUG_PRINT(MPU6050_DMP_CODE_SIZE);\par
    DEBUG_PRINTLN(F(" bytes)"));\par
    if (writeProgMemoryBlock(dmpMemory, MPU6050_DMP_CODE_SIZE)) \{\par
        DEBUG_PRINTLN(F("Success! DMP code written and verified."));\par
\par
        \cf3 // write DMP configuration\cf0\par
        DEBUG_PRINT(F("Writing DMP configuration to MPU memory banks ("));\par
        DEBUG_PRINT(MPU6050_DMP_CONFIG_SIZE);\par
        DEBUG_PRINTLN(F(" bytes in config def)"));\par
        if (writeProgDMPConfigurationSet(dmpConfig, MPU6050_DMP_CONFIG_SIZE)) \{\par
            DEBUG_PRINTLN(F("Success! DMP configuration written and verified."));\par
\par
            DEBUG_PRINTLN(F("Setting clock source to Z Gyro..."));\par
            setClockSource(MPU6050_CLOCK_PLL_ZGYRO);\par
\par
            DEBUG_PRINTLN(F("Setting DMP and FIFO_OFLOW interrupts enabled..."));\par
            setIntEnabled(0x12);\par
\par
            DEBUG_PRINTLN(F("Setting sample rate to 200Hz..."));\par
            setRate(4); \cf3 // 1khz / (1 + 4) = 200 Hz\cf0\par
\par
            DEBUG_PRINTLN(F("Setting external frame sync to TEMP_OUT_L[0]..."));\par
            setExternalFrameSync(MPU6050_EXT_SYNC_TEMP_OUT_L);\par
\par
            DEBUG_PRINTLN(F("Setting DLPF bandwidth to 42Hz..."));\par
            setDLPFMode(MPU6050_DLPF_BW_42);\par
\par
            DEBUG_PRINTLN(F("Setting gyro sensitivity to +/- 2000 deg/sec..."));\par
            setFullScaleGyroRange(MPU6050_GYRO_FS_2000);\par
\par
            DEBUG_PRINTLN(F("Setting DMP configuration bytes (function unknown)..."));\par
            setDMPConfig1(0x03);\par
            setDMPConfig2(0x00);\par
\par
            DEBUG_PRINTLN(F("Clearing OTP Bank flag..."));\par
            setOTPBankValid(false);\par
\par
            DEBUG_PRINTLN(F("Setting X/Y/Z gyro offset TCs to previous values..."));\par
            setXGyroOffsetTC(xgOffsetTC);\par
            setYGyroOffsetTC(ygOffsetTC);\par
            setZGyroOffsetTC(zgOffsetTC);\par
\par
            \cf3 //DEBUG_PRINTLN(F("Setting X/Y/Z gyro user offsets to zero..."));\par
            //setXGyroOffset(0);\par
            //setYGyroOffset(0);\par
            //setZGyroOffset(0);\par
\cf0\par
            DEBUG_PRINTLN(F("Writing final memory update 1/7 (function unknown)..."));\par
            uint8_t dmpUpdate[16], j;\par
            uint16_t pos = 0;\par
            for (j = 0; j < 4 || j < dmpUpdate[2] + 3; j++, pos++) dmpUpdate[j] = pgm_read_byte(&dmpUpdates[pos]);\par
            writeMemoryBlock(dmpUpdate + 3, dmpUpdate[2], dmpUpdate[0], dmpUpdate[1]);\par
\par
            DEBUG_PRINTLN(F("Writing final memory update 2/7 (function unknown)..."));\par
            for (j = 0; j < 4 || j < dmpUpdate[2] + 3; j++, pos++) dmpUpdate[j] = pgm_read_byte(&dmpUpdates[pos]);\par
            writeMemoryBlock(dmpUpdate + 3, dmpUpdate[2], dmpUpdate[0], dmpUpdate[1]);\par
\par
            DEBUG_PRINTLN(F("Resetting FIFO..."));\par
            resetFIFO();\par
\par
            DEBUG_PRINTLN(F("Reading FIFO count..."));\par
            uint16_t fifoCount = getFIFOCount();\par
            uint8_t fifoBuffer[128];\par
\par
            DEBUG_PRINT(F("Current FIFO count="));\par
            DEBUG_PRINTLN(fifoCount);\par
            getFIFOBytes(fifoBuffer, fifoCount);\par
\par
            DEBUG_PRINTLN(F("Setting motion detection threshold to 2..."));\par
            setMotionDetectionThreshold(2);\par
\par
            DEBUG_PRINTLN(F("Setting zero-motion detection threshold to 156..."));\par
            setZeroMotionDetectionThreshold(156);\par
\par
            DEBUG_PRINTLN(F("Setting motion detection duration to 80..."));\par
            setMotionDetectionDuration(80);\par
\par
            DEBUG_PRINTLN(F("Setting zero-motion detection duration to 0..."));\par
            setZeroMotionDetectionDuration(0);\par
\par
            DEBUG_PRINTLN(F("Resetting FIFO..."));\par
            resetFIFO();\par
\par
            DEBUG_PRINTLN(F("Enabling FIFO..."));\par
            setFIFOEnabled(true);\par
\par
            DEBUG_PRINTLN(F("Enabling DMP..."));\par
            setDMPEnabled(true);\par
\par
            DEBUG_PRINTLN(F("Resetting DMP..."));\par
            resetDMP();\par
\par
            DEBUG_PRINTLN(F("Writing final memory update 3/7 (function unknown)..."));\par
            for (j = 0; j < 4 || j < dmpUpdate[2] + 3; j++, pos++) dmpUpdate[j] = pgm_read_byte(&dmpUpdates[pos]);\par
            writeMemoryBlock(dmpUpdate + 3, dmpUpdate[2], dmpUpdate[0], dmpUpdate[1]);\par
\par
            DEBUG_PRINTLN(F("Writing final memory update 4/7 (function unknown)..."));\par
            for (j = 0; j < 4 || j < dmpUpdate[2] + 3; j++, pos++) dmpUpdate[j] = pgm_read_byte(&dmpUpdates[pos]);\par
            writeMemoryBlock(dmpUpdate + 3, dmpUpdate[2], dmpUpdate[0], dmpUpdate[1]);\par
\par
            DEBUG_PRINTLN(F("Writing final memory update 5/7 (function unknown)..."));\par
            for (j = 0; j < 4 || j < dmpUpdate[2] + 3; j++, pos++) dmpUpdate[j] = pgm_read_byte(&dmpUpdates[pos]);\par
            writeMemoryBlock(dmpUpdate + 3, dmpUpdate[2], dmpUpdate[0], dmpUpdate[1]);\par
\par
            DEBUG_PRINTLN(F("Waiting for FIFO count > 2..."));\par
            while ((fifoCount = getFIFOCount()) < 3);\par
\par
            DEBUG_PRINT(F("Current FIFO count="));\par
            DEBUG_PRINTLN(fifoCount);\par
            DEBUG_PRINTLN(F("Reading FIFO data..."));\par
            getFIFOBytes(fifoBuffer, fifoCount);\par
\par
            DEBUG_PRINTLN(F("Reading interrupt status..."));\par
\par
            DEBUG_PRINT(F("Current interrupt status="));\par
            DEBUG_PRINTLNF(getIntStatus(), HEX);\par
\par
            DEBUG_PRINTLN(F("Reading final memory update 6/7 (function unknown)..."));\par
            for (j = 0; j < 4 || j < dmpUpdate[2] + 3; j++, pos++) dmpUpdate[j] = pgm_read_byte(&dmpUpdates[pos]);\par
            readMemoryBlock(dmpUpdate + 3, dmpUpdate[2], dmpUpdate[0], dmpUpdate[1]);\par
\par
            DEBUG_PRINTLN(F("Waiting for FIFO count > 2..."));\par
            while ((fifoCount = getFIFOCount()) < 3);\par
\par
            DEBUG_PRINT(F("Current FIFO count="));\par
            DEBUG_PRINTLN(fifoCount);\par
\par
            DEBUG_PRINTLN(F("Reading FIFO data..."));\par
            getFIFOBytes(fifoBuffer, fifoCount);\par
\par
            DEBUG_PRINTLN(F("Reading interrupt status..."));\par
\par
            DEBUG_PRINT(F("Current interrupt status="));\par
            DEBUG_PRINTLNF(getIntStatus(), HEX);\par
\par
            DEBUG_PRINTLN(F("Writing final memory update 7/7 (function unknown)..."));\par
            for (j = 0; j < 4 || j < dmpUpdate[2] + 3; j++, pos++) dmpUpdate[j] = pgm_read_byte(&dmpUpdates[pos]);\par
            writeMemoryBlock(dmpUpdate + 3, dmpUpdate[2], dmpUpdate[0], dmpUpdate[1]);\par
\par
            DEBUG_PRINTLN(F("DMP is good to go! Finally."));\par
\par
            DEBUG_PRINTLN(F("Disabling DMP (you turn it on later)..."));\par
            setDMPEnabled(false);\par
\par
            DEBUG_PRINTLN(F("Setting up internal 42-byte (default) DMP packet buffer..."));\par
            dmpPacketSize = 42;\par
            /*if ((dmpPacketBuffer = (uint8_t *)malloc(42)) == 0) \{\par
                return 3; \cf3 // TODO: proper error code for no memory\cf0\par
            \}*/\par
\par
            DEBUG_PRINTLN(F("Resetting FIFO and clearing INT status one last time..."));\par
            resetFIFO();\par
            getIntStatus();\par
        \} \par
else \par
\{\par
            DEBUG_PRINTLN(F("ERROR! DMP configuration verification failed."));\par
            return 2; \cf3 // configuration block loading failed\cf0\par
        \}\par
    \} \par
else \par
\{\par
        DEBUG_PRINTLN(F("ERROR! DMP code verification failed."));\par
        return 1; \cf3 // main binary block loading failed\cf0\par
    \}\par
    return 0; \cf3 // success\cf0\par
\}\par
\par
bool MPU6050::dmpPacketAvailable() \{\par
    return getFIFOCount() >= dmpGetFIFOPacketSize();\par
\}\par
\par
\cf3 // uint8_t MPU6050::dmpSetFIFORate(uint8_t fifoRate);\par
// uint8_t MPU6050::dmpGetFIFORate();\par
// uint8_t MPU6050::dmpGetSampleStepSizeMS();\par
// uint8_t MPU6050::dmpGetSampleFrequency();\par
// int32_t MPU6050::dmpDecodeTemperature(int8_t tempReg);\par
\par
//uint8_t MPU6050::dmpRegisterFIFORateProcess(inv_obj_func func, int16_t priority);\par
//uint8_t MPU6050::dmpUnregisterFIFORateProcess(inv_obj_func func);\par
//uint8_t MPU6050::dmpRunFIFORateProcesses();\par
\par
// uint8_t MPU6050::dmpSendQuaternion(uint_fast16_t accuracy);\par
// uint8_t MPU6050::dmpSendGyro(uint_fast16_t elements, uint_fast16_t accuracy);\par
// uint8_t MPU6050::dmpSendAccel(uint_fast16_t elements, uint_fast16_t accuracy);\par
// uint8_t MPU6050::dmpSendLinearAccel(uint_fast16_t elements, uint_fast16_t accuracy);\par
// uint8_t MPU6050::dmpSendLinearAccelInWorld(uint_fast16_t elements, uint_fast16_t accuracy);\par
// uint8_t MPU6050::dmpSendControlData(uint_fast16_t elements, uint_fast16_t accuracy);\par
// uint8_t MPU6050::dmpSendSensorData(uint_fast16_t elements, uint_fast16_t accuracy);\par
// uint8_t MPU6050::dmpSendExternalSensorData(uint_fast16_t elements, uint_fast16_t accuracy);\par
// uint8_t MPU6050::dmpSendGravity(uint_fast16_t elements, uint_fast16_t accuracy);\par
// uint8_t MPU6050::dmpSendPacketNumber(uint_fast16_t accuracy);\par
// uint8_t MPU6050::dmpSendQuantizedAccel(uint_fast16_t elements, uint_fast16_t accuracy);\par
// uint8_t MPU6050::dmpSendEIS(uint_fast16_t elements, uint_fast16_t accuracy);\par
\cf0\par
uint8_t MPU6050::dmpGetAccel(int32_t *data, const uint8_t* packet) \{\par
    \cf3 // TODO: accommodate different arrangements of sent data (ONLY default supported now)\par
\cf0     if (packet == 0) packet = dmpPacketBuffer;\par
    data[0] = (((uint32_t)packet[28] << 24) | ((uint32_t)packet[29] << 16) | ((uint32_t)packet[30] << 8) | packet[31]);\par
    data[1] = (((uint32_t)packet[32] << 24) | ((uint32_t)packet[33] << 16) | ((uint32_t)packet[34] << 8) | packet[35]);\par
    data[2] = (((uint32_t)packet[36] << 24) | ((uint32_t)packet[37] << 16) | ((uint32_t)packet[38] << 8) | packet[39]);\par
    return 0;\par
\}\par
uint8_t MPU6050::dmpGetAccel(int16_t *data, const uint8_t* packet) \{\par
    \cf3 // TODO: accommodate different arrangements of sent data (ONLY default supported now)\cf0\par
    if (packet == 0) packet = dmpPacketBuffer;\par
    data[0] = (packet[28] << 8) | packet[29];\par
    data[1] = (packet[32] << 8) | packet[33];\par
    data[2] = (packet[36] << 8) | packet[37];\par
    return 0;\par
\}\par
uint8_t MPU6050::dmpGetAccel(VectorInt16 *v, const uint8_t* packet) \{\par
    \cf3 // TODO: accommodate different arrangements of sent data (ONLY default supported now)\par
\cf0     if (packet == 0) packet = dmpPacketBuffer;\par
    v -> x = (packet[28] << 8) | packet[29];\par
    v -> y = (packet[32] << 8) | packet[33];\par
    v -> z = (packet[36] << 8) | packet[37];\par
    return 0;\par
\}\par
uint8_t MPU6050::dmpGetQuaternion(int32_t *data, const uint8_t* packet) \{\par
    \cf3 // TODO: accommodate different arrangements of sent data (ONLY default supported now)\par
\cf0     if (packet == 0) packet = dmpPacketBuffer;\par
    data[0] = (((uint32_t)packet[0] << 24) | ((uint32_t)packet[1] << 16) | ((uint32_t)packet[2] << 8) | packet[3]);\par
    data[1] = (((uint32_t)packet[4] << 24) | ((uint32_t)packet[5] << 16) | ((uint32_t)packet[6] << 8) | packet[7]);\par
    data[2] = (((uint32_t)packet[8] << 24) | ((uint32_t)packet[9] << 16) | ((uint32_t)packet[10] << 8) | packet[11]);\par
    data[3] = (((uint32_t)packet[12] << 24) | ((uint32_t)packet[13] << 16) | ((uint32_t)packet[14] << 8) | packet[15]);\par
    return 0;\par
\}\par
uint8_t MPU6050::dmpGetQuaternion(int16_t *data, const uint8_t* packet) \{\par
    \cf3 // TODO: accommodate different arrangements of sent data (ONLY default supported now)\par
\cf0     if (packet == 0) packet = dmpPacketBuffer;\par
    data[0] = ((packet[0] << 8) | packet[1]);\par
    data[1] = ((packet[4] << 8) | packet[5]);\par
    data[2] = ((packet[8] << 8) | packet[9]);\par
    data[3] = ((packet[12] << 8) | packet[13]);\par
    return 0;\par
\}\par
uint8_t MPU6050::dmpGetQuaternion(Quaternion *q, const uint8_t* packet) \{\par
    \cf3 // TODO: accommodate different arrangements of sent data (ONLY default supported now)\cf0\par
    int16_t qI[4];\par
    uint8_t status = dmpGetQuaternion(qI, packet);\par
    if (status == 0) \{\par
        q -> w = (float)qI[0] / 16384.0f;\par
        q -> x = (float)qI[1] / 16384.0f;\par
        q -> y = (float)qI[2] / 16384.0f;\par
        q -> z = (float)qI[3] / 16384.0f;\par
        return 0;\par
    \}\par
    return status; \cf3 // int16 return value, indicates error if this line is reached\par
\cf0\}\par
\cf3 // uint8_t MPU6050::dmpGet6AxisQuaternion(long *data, const uint8_t* packet);\par
// uint8_t MPU6050::dmpGetRelativeQuaternion(long *data, const uint8_t* packet);\par
\cf0 uint8_t MPU6050::dmpGetGyro(int32_t *data, const uint8_t* packet) \{\par
    \cf3 // TODO: accommodate different arrangements of sent data (ONLY default supported now)\par
\cf0     if (packet == 0) packet = dmpPacketBuffer;\par
    data[0] = (((uint32_t)packet[16] << 24) | ((uint32_t)packet[17] << 16) | ((uint32_t)packet[18] << 8) | packet[19]);\par
    data[1] = (((uint32_t)packet[20] << 24) | ((uint32_t)packet[21] << 16) | ((uint32_t)packet[22] << 8) | packet[23]);\par
    data[2] = (((uint32_t)packet[24] << 24) | ((uint32_t)packet[25] << 16) | ((uint32_t)packet[26] << 8) | packet[27]);\par
    return 0;\par
\}\par
uint8_t MPU6050::dmpGetGyro(int16_t *data, const uint8_t* packet) \{\par
    \cf3 // TODO: accommodate different arrangements of sent data (ONLY default supported now)\par
\cf0     if (packet == 0) packet = dmpPacketBuffer;\par
    data[0] = (packet[16] << 8) | packet[17];\par
    data[1] = (packet[20] << 8) | packet[21];\par
    data[2] = (packet[24] << 8) | packet[25];\par
    return 0;\par
\}\par
uint8_t MPU6050::dmpGetGyro(VectorInt16 *v, const uint8_t* packet) \{\par
    \cf3 // TODO: accommodate different arrangements of sent data (ONLY default supported now)\par
\cf0     if (packet == 0) packet = dmpPacketBuffer;\par
    v -> x = (packet[16] << 8) | packet[17];\par
    v -> y = (packet[20] << 8) | packet[21];\par
    v -> z = (packet[24] << 8) | packet[25];\par
    return 0;\par
\}\par
\cf3 // uint8_t MPU6050::dmpSetLinearAccelFilterCoefficient(float coef);\par
// uint8_t MPU6050::dmpGetLinearAccel(long *data, const uint8_t* packet);\par
\cf0\par
uint8_t MPU6050::dmpGetLinearAccel(VectorInt16 *v, VectorInt16 *vRaw, VectorFloat *gravity) \{\par
    \cf3 // get rid of the gravity component (+1g = +8192 in standard DMP FIFO packet, sensitivity is 2g)\par
\cf0     v -> x = vRaw -> x - gravity -> x*8192;\par
    v -> y = vRaw -> y - gravity -> y*8192;\par
    v -> z = vRaw -> z - gravity -> z*8192;\par
    return 0;\par
\}\par
\cf3 // uint8_t MPU6050::dmpGetLinearAccelInWorld(long *data, const uint8_t* packet);\par
\cf0 uint8_t MPU6050::dmpGetLinearAccelInWorld(VectorInt16 *v, VectorInt16 *vReal, Quaternion *q) \{\par
    \cf3 // rotate measured 3D acceleration vector into original state\par
    // frame of reference based on orientation quaternion\cf0\par
    memcpy(v, vReal, sizeof(VectorInt16));\par
    v -> rotate(q);\par
    return 0;\par
\}\par
\cf3 // uint8_t MPU6050::dmpGetGyroAndAccelSensor(long *data, const uint8_t* packet);\par
// uint8_t MPU6050::dmpGetGyroSensor(long *data, const uint8_t* packet);\par
// uint8_t MPU6050::dmpGetControlData(long *data, const uint8_t* packet);\par
// uint8_t MPU6050::dmpGetTemperature(long *data, const uint8_t* packet);\par
// uint8_t MPU6050::dmpGetGravity(long *data, const uint8_t* packet);\par
\cf0 uint8_t MPU6050::dmpGetGravity(VectorFloat *v, Quaternion *q) \{\par
    v -> x = 2 * (q -> x*q -> z - q -> w*q -> y);\par
    v -> y = 2 * (q -> w*q -> x + q -> y*q -> z);\par
    v -> z = q -> w*q -> w - q -> x*q -> x - q -> y*q -> y + q -> z*q -> z;\par
    return 0;\par
\}\par
\cf3 // uint8_t MPU6050::dmpGetUnquantizedAccel(long *data, const uint8_t* packet);\par
// uint8_t MPU6050::dmpGetQuantizedAccel(long *data, const uint8_t* packet);\par
// uint8_t MPU6050::dmpGetExternalSensorData(long *data, int size, const uint8_t* packet);\par
// uint8_t MPU6050::dmpGetEIS(long *data, const uint8_t* packet);\cf0\par
\par
uint8_t MPU6050::dmpGetEuler(float *data, Quaternion *q) \{\par
    data[0] = atan2(2*q -> x*q -> y - 2*q -> w*q -> z, 2*q -> w*q -> w + 2*q -> x*q -> x - 1);   // psi\par
    data[1] = -asin(2*q -> x*q -> z + 2*q -> w*q -> y);                              \cf3 // theta\cf0\par
    data[2] = atan2(2*q -> y*q -> z - 2*q -> w*q -> x, 2*q -> w*q -> w + 2*q -> z*q -> z - 1);   // phi\par
    return 0;\par
\}\par
uint8_t MPU6050::\cf2 dmpGetYawPitchRoll\cf0 (float *data, Quaternion *q, VectorFloat *gravity) \{\par
    \cf3 // yaw: (about Z axis)\par
\cf0     data[0] = atan2(2*q -> x*q -> y - 2*q -> w*q -> z, 2*q -> w*q -> w + 2*q -> x*q -> x - 1);\par
    \cf3 // pitch: (nose up/down, about Y axis)\par
\cf0     data[1] = atan(gravity -> x / sqrt(gravity -> y*gravity -> y + gravity -> z*gravity -> z));\par
    \cf3 // roll: (tilt left/right, about X axis)\par
\cf0     data[2] = atan(gravity -> y / sqrt(gravity -> x*gravity -> x + gravity -> z*gravity -> z));\par
    return 0;\par
\}\par
\par
\cf3 // uint8_t MPU6050::dmpGetAccelFloat(float *data, const uint8_t* packet);\par
// uint8_t MPU6050::dmpGetQuaternionFloat(float *data, const uint8_t* packet);\par
\cf0\par
uint8_t MPU6050::dmpProcessFIFOPacket(const unsigned char *dmpData) \{\par
    /*for (uint8_t k = 0; k < dmpPacketSize; k++) \{\par
        if (dmpData[k] < 0x10) Serial.print("0");\par
        Serial.print(dmpData[k], HEX);\par
        Serial.print(" ");\par
    \}\par
    Serial.print("\\n");*/\par
    \cf3 //Serial.println((uint16_t)dmpPacketBuffer);\cf0\par
    return 0;\par
\}\par
uint8_t MPU6050::dmpReadAndProcessFIFOPacket(uint8_t numPackets, uint8_t *processed) \{\par
    uint8_t status;\par
    uint8_t buf[dmpPacketSize];\par
    for (uint8_t i = 0; i < numPackets; i++) \{\par
        \cf3 // read packet from FIFO\par
\cf0         getFIFOBytes(buf, dmpPacketSize);\par
\par
        \cf3 // process packet\cf0\par
        if ((status = dmpProcessFIFOPacket(buf)) > 0) return status;\par
        \par
        \cf3 // increment external process count variable, if supplied\par
\cf0         if (processed != 0) (*processed)++;\par
    \}\par
    return 0;\par
\}\par
\par
\cf3 // uint8_t MPU6050::dmpSetFIFOProcessedCallback(void (*func) (void));\par
\par
// uint8_t MPU6050::dmpInitFIFOParam();\par
// uint8_t MPU6050::dmpCloseFIFO();\par
// uint8_t MPU6050::dmpSetGyroDataSource(uint_fast8_t source);\par
// uint8_t MPU6050::dmpDecodeQuantizedAccel();\par
// uint32_t MPU6050::dmpGetGyroSumOfSquare();\par
// uint32_t MPU6050::dmpGetAccelSumOfSquare();\par
// void MPU6050::dmpOverrideQuaternion(long *q);\par
\cf0 uint16_t MPU6050::dmpGetFIFOPacketSize() \{\par
    return dmpPacketSize;\par
\}\par
\par
#endif /* _MPU6050_6AXIS_MOTIONAPPS20_H_ */\par
\par
}
 